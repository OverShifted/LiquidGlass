#include "LiquidGlass.h"

#include <imgui.h>
#include "BlurPass.h"

using namespace OverEngine;

#define UPLOAD_UNIFORM(name) { \
	Renderer2D::GetShader()->Bind(); \
	Renderer2D::GetShader()->UploadUniformFloat(#name, name); \
}

LiquidGlass::LiquidGlass()
	: Layer("LiquidGlass")
{
	m_Camera.SetOrthographic(15.0f, -10.0f, 10.0f);
	m_Camera.SetViewportSize(1600, 900);

	m_ScreenCamera.SetOrthographic(1.0f, -10.0f, 10.0f);
	m_ScreenCamera.SetViewportSize(1, 1);

	UploadAllUniforms();
	
	backgrounds.push_back({ 
		"Cubes",
		"Photo credit: \"Cubes\" by Lernert & Sander",
		Texture2D::Create("assets/textures/background-cubes.jpg")
	});

	backgrounds.push_back({ 
		"Spring",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/background-spring.png")
	});

	backgrounds.push_back({ 
		"Summer",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/background-summer.png")
	});

	backgrounds.push_back({ 
		"Autumn",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/background-autumn.png")
	});

	backgrounds.push_back({ 
		"Winter",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/background-winter.png")
	});

	backgrounds.push_back({ 
		"Seasonal Landscape 1",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/Seasonal Landscape 1.png")
	});

	backgrounds.push_back({ 
		"Seasonal Landscape 2",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/Seasonal Landscape 2.png")
	});

	backgrounds.push_back({ 
		"Newspaper",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/Newspaper.png")
	});

	backgrounds.push_back({ 
		"Cartoon Cottage",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/Cartoon Cottage.png")
	});

	backgrounds.push_back({ 
		"Anime girl",
		"Photo generated by OpenAI's Sora",
		Texture2D::Create("assets/textures/anime.png")
	});

	backgrounds.push_back({ 
		"Progressbar",
		"",
		Texture2D::Create("assets/textures/background-progress-bar.jpg")
	});
	
	FrameBufferProps props;
	props.Width = 1600 * aa;
	props.Height = 900 * aa;
	fb = FrameBuffer::Create(props);

	props.Width *= blurDownscaleFactor;
	props.Height *= blurDownscaleFactor;
	blurFinal = FrameBuffer::Create(props);
	blurIntermediate = FrameBuffer::Create(props);
	
	blurPass = CreateScope<BlurPass>();
	blurPass->OnResize(1600, 900);
	blurPass->GetShader()->Bind();
	blurPass->GetShader()->UploadUniformFloat("u_radius", u_blurRadius);
}

void LiquidGlass::UploadAllUniforms() {
	UPLOAD_UNIFORM(u_powerFactor)
	UPLOAD_UNIFORM(u_a);
	UPLOAD_UNIFORM(u_b);
	UPLOAD_UNIFORM(u_c);
	UPLOAD_UNIFORM(u_d);
	UPLOAD_UNIFORM(u_fPower);
	UPLOAD_UNIFORM(u_noise);
	UPLOAD_UNIFORM(u_glowWeight);
	UPLOAD_UNIFORM(u_glowBias);
	UPLOAD_UNIFORM(u_glowEdge0);
	UPLOAD_UNIFORM(u_glowEdge1);
}

void LiquidGlass::OnUpdate(TimeStep deltaTime)
{
	lastDeltaTime = deltaTime;

	if (!mouseControl) {
		bool anyKeyPressed = false;
		if (Input::IsKeyPressed(KeyCode::W)) {
			m_Position.y += deltaTime * velocityMultiplier * velocity;
			anyKeyPressed = true;
		}

		if (Input::IsKeyPressed(KeyCode::S)) {
			m_Position.y -= deltaTime * velocityMultiplier * velocity;
			anyKeyPressed = true;
		}

		if (Input::IsKeyPressed(KeyCode::D)) {
			m_Position.x += deltaTime * velocityMultiplier * velocity;
			anyKeyPressed = true;
		}

		if (Input::IsKeyPressed(KeyCode::A)) {
			m_Position.x -= deltaTime * velocityMultiplier * velocity;
			anyKeyPressed = true;
		}

		if (anyKeyPressed) {
			velocityMultiplier += 1.0 * deltaTime;
		} else {
			velocityMultiplier -= 3.0 * deltaTime;
		}

		velocityMultiplier = Math::Clamp(velocityMultiplier, 0.0f, 1.0f);
	}

	{
		bool anyKeyPressed = false;
		if (Input::IsKeyPressed(KeyCode::Up)) {
			m_CameraPosition.y -= deltaTime * cameraVelocityMultiplier * cameraVelocity;
			anyKeyPressed = true;
		}

		if (Input::IsKeyPressed(KeyCode::Down)) {
			m_CameraPosition.y += deltaTime * cameraVelocityMultiplier * cameraVelocity;
			anyKeyPressed = true;
		}

		if (Input::IsKeyPressed(KeyCode::Right)) {
			m_CameraPosition.x -= deltaTime * cameraVelocityMultiplier * cameraVelocity;
			anyKeyPressed = true;
		}

		if (Input::IsKeyPressed(KeyCode::Left)) {
			m_CameraPosition.x += deltaTime * cameraVelocityMultiplier * cameraVelocity;
			anyKeyPressed = true;
		}

		if (anyKeyPressed) {
			cameraVelocityMultiplier += 1.0 * deltaTime;
		} else {
			cameraVelocityMultiplier -= 3.0 * deltaTime;
		}

		cameraVelocityMultiplier = Math::Clamp(cameraVelocityMultiplier, 0.0f, 1.0f);
	}

	Window& window = Application::Get().GetWindow();

	if (mouseControl) {
		Vector2 mousePos = 2.0f * Input::GetMousePosition() / Vector2(window.GetWidth(), window.GetHeight()) - 1.0f;
		mousePos.y *= -1.0f;
		Mat4x4 vpMatrix = m_Camera.GetProjection() * glm::translate(IDENTITY_MAT4X4, m_CameraPosition);
		Mat4x4 vpMatrixInverse = glm::inverse(vpMatrix);
		Vector4 mouseInWorld = vpMatrixInverse * Vector4(mousePos, 1.0, 1.0);
		
		m_Position.x = mouseInWorld.x;
		m_Position.y = mouseInWorld.y;
	}

	// Draw the bg scene
	{
		fb->Bind();
		RenderCommand::SetClearColor(Color{ 0.1, 0.1, 0.1, 1.0 });
		RenderCommand::Clear(ClearFlags_ClearColor | ClearFlags_ClearDepth);

		Renderer2D::BeginScene(glm::translate(IDENTITY_MAT4X4, m_CameraPosition), m_Camera);
		// Renderer2D::DrawQuad({ 0.7, 0.0, 0.0 }, glm::radians(30.0), { 1.2, 1.2 }, Color{ 1, 0.3, 0.2, 1.0 });
		// Renderer2D::DrawQuad({ -0.4, 1.0, 0.0 }, glm::radians(-30.0), { 1.2, 1.2 }, Color{ 0.3, 0.3, 1.0, 1.0 });
		// Renderer2D::DrawQuad({ 0.0, 0.0, 0.0 }, glm::radians(0.0), { 26, 20.61 }, TexturedQuadProps { .Sprite = bg });
		Renderer2D::DrawQuad({ 0.0, 0.0, 0.0 }, glm::radians(0.0), { 10, (float) CurrentBackground().texture->GetHeight() / (float) CurrentBackground().texture->GetWidth() * 10.0f }, TexturedQuadProps { .Sprite = CurrentBackground().texture });
		Renderer2D::EndScene();
	}

	blurPass->Run(fb, blurIntermediate, blurFinal, blurIters);

	fb->Unbind();
	Renderer::OnWindowResize(window.GetWidth(), window.GetHeight());

	// Draw the final scene into a high resolution frame buffer
	{
		// finalFb->Bind();
		RenderCommand::SetClearColor(Color{ 0.1, 0.1, 0.1, 1.0 });
		RenderCommand::Clear(ClearFlags_ClearColor | ClearFlags_ClearDepth);
		
		// Render the framebuffer behind liquid glass
		{
			Renderer2D::BeginScene(IDENTITY_MAT4X4, m_ScreenCamera);
			Renderer2D::DrawQuad({0, 0, -1}, glm::radians(0.0), Vector2{ 1 }, Color{ 1 }, 2);
			fb->BindColorAttachment(5);
			Renderer2D::EndScene();
		}
		
		Renderer2D::BeginScene(glm::translate(IDENTITY_MAT4X4, m_CameraPosition), m_Camera);
		Renderer2D::DrawQuad(m_Position, glm::radians(0.0), Vector2{ width, height }, Color{ 1 }, 1);
		blurFinal->BindColorAttachment(5);
		Renderer2D::EndScene();
	}

	// finalFb->Unbind();
	// Renderer::OnWindowResize(window.GetWidth(), window.GetHeight());

	// {
	// 	RenderCommand::SetClearColor(Color{ 0.1, 0.1, 0.1, 1.0 });
	// 	RenderCommand::Clear(ClearFlags_ClearColor | ClearFlags_ClearDepth);

	// 	// Render the framebuffer behind liquid glass
	// 	{
	// 		Renderer2D::BeginScene(IDENTITY_MAT4X4, m_ScreenCamera);
	// 		Renderer2D::DrawQuad({0, 0, -1}, glm::radians(0.0), Vector2{ 1 }, Color{ 1 }, 2);
	// 		finalFb->BindColorAttachment(5);
	// 		Renderer2D::EndScene();
	// 	}
	// }
}

void LiquidGlass::OnImGuiRender()
{
	// ImGui::GetStyle().Alpha = 0.8;
	ImGui::Begin("Settings");
	Window& window = Application::Get().GetWindow();

	if (ImGui::BeginCombo("Background", CurrentBackground().name.c_str())) {
		int i = 0;
		for (Background& bg : backgrounds) {
			bool isSelected = i == backgroundId;
			if (ImGui::Selectable(bg.name.c_str(), isSelected))
				backgroundId = i;
			if (isSelected)
				ImGui::SetItemDefaultFocus();
			i++;
		}
		ImGui::EndCombo();
	}

	ImGui::Checkbox("Move with mouse", &mouseControl);

	ImGui::Dummy({ 0.0, 8.0 });

	if (ImGui::CollapsingHeader("Shape", ImGuiTreeNodeFlags_DefaultOpen)) {
		// FIXME: power of exactly 1 causes visual artifacts
		if (ImGui::SliderFloat("Power", &u_powerFactor, 1.001, 6.0)) UPLOAD_UNIFORM(u_powerFactor);
		ImGui::SliderFloat("Width", &width, 0.0, 10.0);
		ImGui::SliderFloat("Height", &height, 0.0, 10.0);
	}
	
	ImGui::Dummy({ 0.0, 5.0 });

	if (ImGui::CollapsingHeader("Blur & Noise", ImGuiTreeNodeFlags_DefaultOpen)) {
		ImGui::SliderInt("Blur Iters", &blurIters, 0.0, 10.0);
		if (ImGui::SliderFloat("Blur Radius", &u_blurRadius, 0.0, 10.0)) {
			blurPass->GetShader()->Bind();
			blurPass->GetShader()->UploadUniformFloat("u_radius", u_blurRadius);
		}
		
		if (ImGui::SliderFloat("Blur downscale", &blurDownscaleFactor, 0.1, 1.0)) {
			blurFinal->Resize(window.GetWidth() * blurDownscaleFactor, window.GetHeight() * blurDownscaleFactor);
			blurIntermediate->Resize(window.GetWidth() * blurDownscaleFactor, window.GetHeight() * blurDownscaleFactor);
		}
		
		if (ImGui::SliderFloat("Noise", &u_noise, 0, 0.3)) UPLOAD_UNIFORM(u_noise);
	}
	
	ImGui::Dummy({ 0.0, 5.0 });
	
	if (ImGui::CollapsingHeader("Refraction", ImGuiTreeNodeFlags_DefaultOpen)) {
		ImGui::Text("%s", "f(x) = 1 - b (ce)^(-dx-a)");
		if (ImGui::SliderFloat("f(x) Power", &u_fPower, -1.5, 6.0)) UPLOAD_UNIFORM(u_fPower);
		if (ImGui::SliderFloat("a", &u_a, 0.0, 5.0)) UPLOAD_UNIFORM(u_a);
		if (ImGui::SliderFloat("b", &u_b, 0.0, 6.0)) UPLOAD_UNIFORM(u_b);
		if (ImGui::SliderFloat("c", &u_c, 0.0, 6.0)) UPLOAD_UNIFORM(u_c);
		if (ImGui::SliderFloat("d", &u_d, 0.0, 10.0)) UPLOAD_UNIFORM(u_d);
	}

	ImGui::Dummy({ 0.0, 5.0 });

	if (ImGui::CollapsingHeader("Glow", ImGuiTreeNodeFlags_DefaultOpen)) {
		if (ImGui::SliderFloat("Glow weight", &u_glowWeight, -1.0, 1.0)) UPLOAD_UNIFORM(u_glowWeight);
		if (ImGui::SliderFloat("Glow bias", &u_glowBias, -1.0, 1.0)) UPLOAD_UNIFORM(u_glowBias);
		if (ImGui::SliderFloat("Glow edge0", &u_glowEdge0, -1.0, 1.0)) UPLOAD_UNIFORM(u_glowEdge0);
		if (ImGui::SliderFloat("Glow edge1", &u_glowEdge1, -1.0, 1.0)) UPLOAD_UNIFORM(u_glowEdge1);
	}

	ImGui::Dummy({ 0.0, 5.0 });
	
	// ImGui::Text("%f", velocityMultiplier);
	// ImGui::Text("%f", cameraVelocityMultiplier);
	ImGui::Text("%.0f FPS", 1 / lastDeltaTime);
	if (ImGui::Button("Reload shader")) {
		Renderer2D::ReloadShader();
		UploadAllUniforms();
	}

	bool vSync = window.IsVSync();
	if (ImGui::Checkbox("VSync", &vSync)) {
		window.SetVSync(vSync);
	}

	ImGui::Dummy({ 0.0, 20.0 });
	ImGui::TextDisabled("%s", CurrentBackground().credits.c_str());
	ImGui::End();
	// ImGui::PopStyleVar();

	// ImGui::Begin("fb");
	// float availWidth = ImGui::GetContentRegionAvail().x;
	// ImGui::Image((void*) fb->GetColorAttachmentRendererID(), { availWidth, availWidth / fb->GetProps().Width * fb->GetProps().Height }, { 0, 1 }, { 1, 0 });
	// ImGui::End();

	// ImGui::Begin("finalFb");
	// ImGui::Image((void*) finalFb->GetColorAttachmentRendererID(), ImGui::GetContentRegionAvail(), { 0, 1 }, { 1, 0 });
	// ImGui::End();

	// ImGui::Begin("blurIntermediate");
	// availWidth = ImGui::GetContentRegionAvail().x;
	// ImGui::Image((void*) blurIntermediate->GetColorAttachmentRendererID(), { availWidth, availWidth / fb->GetProps().Width * fb->GetProps().Height }, { 0, 1 }, { 1, 0 });
	// ImGui::End();

	// ImGui::Begin("blurFinal");
	// availWidth = ImGui::GetContentRegionAvail().x;
	// ImGui::Image((void*) blurFinal->GetColorAttachmentRendererID(), { availWidth, availWidth / fb->GetProps().Width * fb->GetProps().Height }, { 0, 1 }, { 1, 0 });
	// ImGui::End();
}

void LiquidGlass::OnEvent(Event& event)
{
	OE_PROFILE_FUNCTION();

	EventDispatcher dispatcher(event);
	dispatcher.Dispatch<WindowResizeEvent>([this](WindowResizeEvent& e) {
		this->m_Camera.SetViewportSize(e.GetWidth(), e.GetHeight());
		fb->Resize(e.GetWidth() * aa, e.GetHeight() * aa);
		// finalFb->Resize(e.GetWidth() * aa, e.GetHeight() * aa);
		blurFinal->Resize(e.GetWidth() * blurDownscaleFactor, e.GetHeight() * blurDownscaleFactor);
		blurIntermediate->Resize(e.GetWidth() * blurDownscaleFactor, e.GetHeight() * blurDownscaleFactor);
		blurPass->OnResize(e.GetWidth(), e.GetHeight());

		return false;
	});

	dispatcher.Dispatch<MouseScrolledEvent>([this](MouseScrolledEvent& e) {
		float size = glm::max(0.1, m_Camera.GetOrthographicSize() - e.GetYOffset() * 0.7);
		m_Camera.SetOrthographicSize(size);
		return false;
	});
}
